# Кастомный пул потоков

`CustomThreadPool` — это учебная реализация пула потоков, созданная в исследовательских целях. Система разработана для изучения принципов многопоточности и управления задачами в Java. Пул потоков поддерживает настраиваемые параметры, балансировку нагрузки, сбор метрик и различные политики обработки отказов, обеспечивая гибкость и расширяемость в управлении параллельным выполнением.

## Основные возможности

### Гибкая настройка параметров

- `corePoolSize` — минимальное количество потоков.
- `maxPoolSize` — максимальное количество потоков.
- `keepAliveTime` — время ожидания перед завершением избыточных потоков.
- `queueSize` — ограничение на размер очередей.
- `minSpareThreads` — минимальное количество «резервных» потоков.

### Управление жизненным циклом

- `shutdown()` — корректное завершение с обработкой оставшихся задач.
- `shutdownNow()` — принудительная остановка.
- `awaitTermination(timeout)` — ожидание завершения всех потоков.

### Метрики
Сбор статистики по:

- количеству выполненных задач,
- времени выполнения,
- размеру очередей,
- числу отклонённых задач.

## Применение
`CustomThreadPool` подходит для сценариев, где важно:

- точно контролировать поведение пула при перегрузке,
- отслеживать производительность и поведение задач,
- расширять и адаптировать пул под специфические требования.

## Производительность
Сравнение с существующими пулами потоков
### ThreadPoolExecutor (стандартная реализация):

- Использует одну общую очередь задач для всех потоков.
- Обладает простой архитектурой, но при высокой нагрузке может становиться узким местом из-за конкуренции за очередь.
- Не поддерживает параметр minSpareThreads, что может снижать отзывчивость при резких всплесках нагрузки.

### ForkJoinPool:

- Оптимизирован для задач с возможностью деления (fork-join модель).
- Использует стратегию work-stealing для балансировки нагрузки.
- Менее эффективен для независимых и короткоживущих задач.

### CustomThreadPool (данная реализация):

- Использует отдельную очередь задач для каждого потока, что снижает конкуренцию между потоками.
- Реализует стратегию балансировки нагрузки на основе наименьшей загруженности.
- Поддерживает minSpareThreads для быстрого масштабирования при росте нагрузки.
- Более сложная архитектура по сравнению со стандартными реализациями.
- Присутствуют дополнительные накладные расходы, связанные с управлением несколькими очередями и механизмом балансировки.