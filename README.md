# Кастомный пул потоков

`CustomThreadPool` — это учебная реализация пула потоков, созданная в исследовательских целях. Система разработана для
изучения принципов многопоточности и управления задачами в Java. Пул потоков поддерживает настраиваемые параметры,
балансировку нагрузки, сбор метрик и различные политики обработки отказов, обеспечивая гибкость и расширяемость в
управлении параллельным выполнением.

## Основные возможности

### Гибкая настройка параметров

- `corePoolSize` — минимальное количество потоков.
- `maxPoolSize` — максимальное количество потоков.
- `keepAliveTime` — время ожидания перед завершением избыточных потоков.
- `queueSize` — ограничение на размер очередей.
- `minSpareThreads` — минимальное количество «резервных» потоков.

### Управление жизненным циклом

- `shutdown()` — корректное завершение с обработкой оставшихся задач.
- `shutdownNow()` — принудительная остановка.
- `awaitTermination(timeout)` — ожидание завершения всех потоков.

### Метрики

Сбор статистики по:

- количеству выполненных задач
- времени выполнения
- размеру очередей
- числу отклонённых задач

## Применение

`CustomThreadPool` подходит для сценариев, где важно:

- точно контролировать поведение пула при перегрузке,
- отслеживать производительность и поведение задач,
- расширять и адаптировать пул под специфические требования.

## Производительность

Сравнение с существующими пулами потоков

### ThreadPoolExecutor (стандартная реализация):

- Использует одну общую очередь задач для всех потоков.
- Обладает простой архитектурой, но при высокой нагрузке может становиться узким местом из-за конкуренции за очередь.
- Не поддерживает параметр minSpareThreads, что может снижать отзывчивость при резких всплесках нагрузки.

### ForkJoinPool:

- Оптимизирован для задач с возможностью деления (fork-join модель).
- Использует стратегию work-stealing для балансировки нагрузки.
- Менее эффективен для независимых и короткоживущих задач.

### CustomThreadPool (данная реализация):

- Использует отдельную очередь задач для каждого потока, что снижает конкуренцию между потоками.
- Поддерживает minSpareThreads для быстрого масштабирования при росте нагрузки.
- Присутствуют дополнительные накладные расходы, связанные с управлением несколькими очередями и механизмом
  балансировки.

## Бенчмарки

Бенчмарки можно запустить локально, весь нужный код находится в `src/main/java/benchmarks/Main`

При замерах для `CustomThreadPool` и `ThreadPoolExecutor` использовались следующие настройки:

- corePoolSize = 2
- maxPoolSize = 4
- queueSize = 5
- keepAliveTime = 5

### Результаты

#### 100 задач, каждая по 10мс

|                                  | CustomThreadPool | ThreadPoolExecutor | ForkJoinPool | SingleThreadExecutor |
|----------------------------------|------------------|--------------------|--------------|----------------------| 
| Время выполнения (в среднем), мс | 283              | 137                | 155          | 1214                 |

#### 100 задач, каждая по 100мс

|                                  | CustomThreadPool | ThreadPoolExecutor | ForkJoinPool | SingleThreadExecutor |
|----------------------------------|------------------|--------------------|--------------|----------------------| 
| Время выполнения (в среднем), мс | 1876             | 1145               | 1350         | 10396                |                  

### Итог замера производительности

`CustomThreadPool` показывает себя на порядок лучше, чем реализация с использованием одного потока. 
При этом есть отставание от `ThreadPool` (но у него и больше rejected задач) и меньше от `ForkJoinPool`.
Отставание, вероятно, получится сократить, если ввести более сложный алгоритм распределения нагрузки между воркерами, а также подобрать подходящий rejection policy.