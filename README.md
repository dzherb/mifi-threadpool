# Кастомный пул потоков

`CustomThreadPool` — это учебная реализация пула потоков, созданная в исследовательских целях. Система разработана для
изучения принципов многопоточности и управления задачами в Java. Пул потоков поддерживает настраиваемые параметры,
балансировку нагрузки, сбор метрик и различные политики обработки отказов, обеспечивая гибкость и расширяемость в
управлении параллельным выполнением.

## Основные возможности

### Гибкая настройка параметров

- `corePoolSize` — минимальное количество потоков.
- `maxPoolSize` — максимальное количество потоков.
- `keepAliveTime` — время ожидания перед завершением избыточных потоков.
- `queueSize` — ограничение на размер очередей.
- `minSpareThreads` — минимальное количество «резервных» потоков.

### Управление жизненным циклом

- `shutdown()` — корректное завершение с обработкой оставшихся задач.
- `shutdownNow()` — принудительная остановка.
- `awaitTermination(timeout)` — ожидание завершения всех потоков.

### Метрики

Сбор статистики по:

- количеству выполненных задач
- времени выполнения
- размеру очередей
- числу отклонённых задач

## Применение

`CustomThreadPool` подходит для сценариев, где важно:

- точно контролировать поведение пула при перегрузке,
- отслеживать производительность и поведение задач,
- расширять и адаптировать пул под специфические требования.

## Запуск демонстрационной программы

Пример использования `CustomThreadPool` находится по пути `src/main/java/examples/CustomThreadPoolExample.java`

Достаточно выполнить:

```shell
# Компилируем исходники
javac -d out src/**/*.java
# Запускаем демо-программу
java -cp out examples/CustomThreadPoolExample
```

## Архитектура

### Балансировка нагрузки

В текущей реализации используется балансировка по алгоритму [Round-robin](https://ru.wikipedia.org/wiki/Round-robin_(алгоритм)). Это простая реализация, когда задачи попадают к каждому воркеру "по-кругу". 
Для этого используется внутренний атомарный счетчик задач, а нужный воркер подбирается путем остатка от деления счетчика на общее количество воркеров.

### Логирование

Реализация `CustomThreadPool` применяет логирование, которое покрывает все ключевые этапы работы системы. 
Также дополнительно были реализованы классы `LoggingRejectionHandler` и `LoggingThreadFactory` для логирования отмененных задач и создания новых потоков.

### Политика отказа

Фактически реализована политика `DiscardPolicy`. 
Когда очередь воркера переполнена, вызывается метод `rejectedExecution` у класса `LoggingRejectionHandler`, который только логирует факт отмены задачи. 
Это простой подход, не требующий дополнительной нагрузки, но из минусов - есть шанс потерять задачи.

## Производительность

Сравнение с существующими пулами потоков

### ThreadPoolExecutor (стандартная реализация):

- Использует одну общую очередь задач для всех потоков.
- Обладает простой архитектурой, но при высокой нагрузке может становиться узким местом из-за конкуренции за очередь.
- Не поддерживает параметр minSpareThreads, что может снижать отзывчивость при резких всплесках нагрузки.

### ForkJoinPool:

- Оптимизирован для задач с возможностью деления (fork-join модель).
- Использует стратегию work-stealing для балансировки нагрузки.
- Менее эффективен для независимых и короткоживущих задач.

### CustomThreadPool (данная реализация):

- Использует отдельную очередь задач для каждого потока, что снижает конкуренцию между потоками.
- Поддерживает minSpareThreads для быстрого масштабирования при росте нагрузки.
- Присутствуют дополнительные накладные расходы, связанные с управлением несколькими очередями и механизмом
  балансировки.

## Бенчмарки

Бенчмарки можно запустить локально, весь нужный код находится в `src/main/java/benchmarks/Main`

При замерах для `CustomThreadPool` и `ThreadPoolExecutor` использовались следующие настройки:

- corePoolSize = 2
- maxPoolSize = 4
- queueSize = 5
- keepAliveTime = 5

### Результаты

#### 100 задач, каждая по 10мс

|                                  | CustomThreadPool | ThreadPoolExecutor | ForkJoinPool | SingleThreadExecutor |
|----------------------------------|------------------|--------------------|--------------|----------------------| 
| Время выполнения (в среднем), мс | 283              | 137                | 155          | 1214                 |

#### 100 задач, каждая по 100мс

|                                  | CustomThreadPool | ThreadPoolExecutor | ForkJoinPool | SingleThreadExecutor |
|----------------------------------|------------------|--------------------|--------------|----------------------| 
| Время выполнения (в среднем), мс | 1876             | 1145               | 1350         | 10396                |                  

### Итог замера производительности

`CustomThreadPool` показывает себя на порядок лучше, чем реализация с использованием одного потока. 
При этом есть отставание от `ThreadPoolExecutor` (но у него и больше rejected задач) и меньше от `ForkJoinPool`.
Отставание, вероятно, получится сократить, если ввести более сложный алгоритм балансировки нагрузки между воркерами, а также исследовать альтернативные варианты **rejection policy**. 

На скорость также оказывает влияние наличие отдельных очередей на каждый поток в реализации `CustomThreadPool` и общий мьютекс. 
Если снизить `queueSize` до 10-12, то количество отмененных задач будет соразмерно с `ThreadPoolExecutor` с лимитом очереди в 80, а отставание сократится до ~70мс.